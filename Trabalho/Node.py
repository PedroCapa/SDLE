from math import log2, floor
import random


class Node:
    """
    Super Class Node
    """
    def handle(self, source, msg):
        pass


class PushSumProtocol(Node):
    """
    Class used to implement the push sum protocol

    Attributes
    ----------
    neighbors: list
        list of neighbors of the node
    name: int
        name of the node
    values: (float, float)
        pair of values corresponding to the current values of the node
    processess: list
        list of all processess in the network
    data: dictionary
        contains the data of messages
    info: dictionary
        info about the others node
    target: dictionary
        the targets of the messages
    counter: int
        number of messages generated by the node
    """
    def __init__(self, neighbors, name, values, fanout, processess):
        """
        Parameters
        ----------
        neighbors : list
            list of neighbors of the node
        name : int
            name of the node
        values : (float, float)
            pair of values corresponding to the current values of the node
        processess : list
            list of all processess in the network
        """
        self.neighbors = neighbors
        self.name = name
        self.info = {}
        self.data = {}
        self.target = {}
        self.values = values
        self.counter = 0
        self.fanout = fanout
        for process in processess:
            self.info[process] = set()

    def setWeight(self, weight):
        """
        Sets the weight value of the node

        Parameters
        ----------
        weight: float
            new weight of the node
        """
        value = self.values[0]
        self.values = (value, weight)

    def getRealValue(self):
        """
        Computes the real value of the node by dividing
        the first value by the second

        Returns
        ----------
        float
            the real value of the node
        """
        if self.values[1] == 0:
            self.realValue = 0
            return self.realValue
        self.realValue = self.values[0] / self.values[1]
        return self.realValue

    def finish(self, result, terminationError):
        """
        Computes the error of the node and tells if the error is low enough

        Parameters
        ----------
        result: float
            the target value
        terminationError: float
            the fraction of the desired error

        Returns
        ----------
        boolean
            if the error is low enough
        """
        return (abs(self.getRealValue() - result) / result < terminationError)

    # src = proprio nodo
    # message = ('gossip', src, target, (id, data))
    def handle(self, source, msg):
        """
        Handles an event

        Parameters
        ----------
        source: int
            the node
        msg: dictionary
            the event received by the node

        Returns
        ----------
        list
            list of events generated by the event
        """
        def handleGossip(self, src, msg):
            """
            Handles an event of type gossip

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            res = []
            id = msg['id']
            data = msg['data']
            target = msg['target']
            previous = msg['previous']

            # if the target already knows we do nothing
            if id in self.info[target] or id in self.info[source]:
                return res

            # update the info of the previous and ours
            self.data[id] = data
            self.info[src].add(id)
            self.info[previous].add(id)
            self.target[id] = target

            # if we are the target we do the math
            if target == src:
                self.values = (self.values[0] + data[0],
                               self.values[1] + data[1])

            # if the target is our neighbord send a gossip to him
            elif target in self.neighbors:
                message = {'type': 'gossip', 'previous': self.name,
                           'target': target, 'id': id, 'data': data}
                res.append((message, target))
                message = {'type': 'collector', 'id': id}
                res.append((message, src))

            # else send a gossip and send multiple WeHave
            else:
                gossip = self.getRandomNeighbors(previous, id)
                ihave = self.getIHaveNeighbors(previous, gossip)
                # Adiciona a lista de mensagens das duas
                res.extend(self.addGossipMessages(gossip, id))
                res.extend(self.addIHaveMessages(ihave, id))
                message = {'type': 'collector', 'id': id}
                res.append((message, src))

            return res

        def handleIHave(self, src, msg):
            """
            Handles an event of type ihave

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            res = []
            id = msg['id']
            target = msg['target']
            previous = msg['previous']

            # Add the info
            self.info[previous].add(id)
            self.target[id] = target

            # if we are the the target and we do not have the data
            if target == src and id not in self.info[src]:
                message = {'type': 'request', 'previous': self.name, 'id': id}
                res.append((message, previous))

            # if we are the target and we have the data
            elif target == src:
                return []

            # Add the schedule to ask for the data
            schedule = {'type': 'schedule', 'id': id}
            res.append((schedule, src))

            return res

        def handleSchedule(self, src, msg):
            """
            Handles an event of type schedule

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            res = []
            id = msg['id']
            target = self.target[id]

            # If we have the info that the target already has the data
            if id in self.info[target]:
                return []
            # If we are not the target but we have the data
            elif id in self.info[self.name]:
                return []

            # Ask for data
            nei = self.neighborKnowsInfo(id)
            if len(nei) > 0:
                request = {'type': 'request', 'previous': self.name, 'id': id}
                res.append((request, nei[0]))

            # Reschedule the schedule
            schedule = {'type': 'schedule', 'id': id}
            res.append((schedule, self.name))

            return res

        def handleRequest(self, src, msg):
            """
            Handles an event of type request

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            previous = msg['previous']
            id = msg['id']
            res = []
            target = self.target[id]
            # just reply if we don't have the
            # info that the target already has the data
            if id not in self.info[target] and previous in self.neighbors:
                data = self.data[id]
                message = {'type': 'gossip', 'previous': self.name,
                           'target': target, 'id': id, 'data': data}
                res.append((message, previous))
            return res

        def handleKnowledge(self, src, msg):
            """
            Handles an event of type knowledge

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            matrix = self.infoToMatrix()
            res = []
            # send to all the neighbors info
            for neighbor in self.neighbors:
                message = {'type': 'wehave', 'previous': self.name,
                           'info': matrix}
                res.append((message, neighbor))
            # if target already received the data remove from data dictionary
            aux = self.data.copy()
            for (id, _) in aux.items():
                dataTarget = self.target[id]
                if id in self.info[dataTarget]:
                    del self.data[id]

            message = {'type': 'knowledge'}
            res.append((message, src))
            return res

        def handleWeHave(self, src, msg):
            """
            Handles an event of type wehave

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            new_info = self.matrixToInfo(msg['info'])
            res = []

            for (key, value) in new_info.items():
                self.info[key] = value.union(self.info[key])

            return res

        def handleIterator(self, src, msg):
            """
            Handles an event of type iterator

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            res = []
            # create a new iterator
            message = {'type': 'iterator'}
            res.append((message, source))
            # if weight is above 0 send a gossip and collector
            # add to data, to my info and to target and update counter
            if self.values[1] > 0:
                id = self.updateLocal()
                gossipNeighbors = [self.target[id]]
                aux = self.addGossipMessages(gossipNeighbors, id)
                res.extend(aux)
                ihaveNeighbors = self.getIHaveNeighbors(-1, gossipNeighbors)
                aux = self.addIHaveMessages(ihaveNeighbors, id)
                res.extend(aux)
                message = {'type': 'collector', 'id': id}
                res.append((message, src))
            return res

        def handleCollector(self, src, msg):
            """
            Handles an event of type collector

            Parameters
            ----------
            source: int
                the node
            msg: dictionary
                the event received by the node

            Returns
            ----------
            list
                list of events generated by the event
            """
            res = []
            id = msg['id']
            target = self.target[id]

            if id in self.info[target]:
                return res

            elif target in self.neighbors and id not in self.info[target]:
                gossipNeighbors = [self.target[id]]
                gossip = self.addGossipMessages(gossipNeighbors, id)
                ihaveNeighbors = self.getIHaveNeighbors(-1, gossipNeighbors)
                ihave = self.addIHaveMessages(ihaveNeighbors, id)
                res = gossip + ihave
                message = {'type': 'collector', 'id': id}
                res.append((message, src))

            elif target not in self.neighbors:
                ihaveNeighbors = self.getIHaveNeighbors(-1, [])
                res = self.addIHaveMessages(ihaveNeighbors, id)
                message = {'type': 'collector', 'id': id}
                res.append((message, src))

            return res

        switch = {
            "gossip": handleGossip,
            "ihave": handleIHave,
            "schedule": handleSchedule,
            "request": handleRequest,
            "knowledge": handleKnowledge,
            "wehave": handleWeHave,
            "iterator": handleIterator,
            "collector": handleCollector,
        }
        return switch.get(msg['type'])(self, source, msg)

    def addIHaveMessages(self, targets, id):
        """
        Generate a list of ihave events

        Parameters
        ----------
        targets: list
            list of neighbors to send the message
        id: int
            id of the message to send

        Returns
        ----------
        list
            list of ihave events
        """
        res = []
        target = self.target[id]
        for tar in targets:
            message = {'type': 'ihave', 'previous': self.name,
                       'target': target, 'id': id}
            res.append((message, tar))
        return res

    def addGossipMessages(self, targets, id):
        """
        Generate a list of gossip events

        Parameters
        ----------
        targets: list
            list of neighbors to send the message
        id: int
            id of the message to send

        Returns
        ----------
        list
            list of gossip events
        """
        res = []
        target = self.target[id]
        data = self.data[id]
        for tar in targets:
            message = {'type': 'gossip', 'previous': self.name,
                       'target': target, 'id': id, 'data': data}
            res.append((message, tar))
        return res

    def neighborKnowsInfo(self, id):
        """
        Computes the list of neighbors that have the data

        Parameters
        ----------
        id: int
            id of the message to request

        Returns
        ----------
        list
            list of neighbors that have the data
        """
        return [nei for nei in self.neighbors if id in self.info[nei]]

    def getRandomNeighbors(self, previous, id):
        """
        Random neigbors to send a gossip message

        Parameters
        ----------
        previous: int
            the node that sent the gossip
        id: int
            id of the message to send

        Returns
        ----------
        list
            list of neighbors to send the gossip message
        """
        aux = [x for x in self.neighbors if id not in self.info[x]]
        if previous in aux:
            aux.remove(previous)
        if self.fanout >= len(aux):
            return aux
        return random.sample(aux, self.fanout)

    def getIHaveNeighbors(self, previous, gossip):
        """
        Random neigbors to send a ihave message

        Parameters
        ----------
        previous: int
            the node that sent the ihave
        gossip: list
            list of neighbors that were sent a gossip message

        Returns
        ----------
        list
            list of neighbors to send the ihave message
        """
        # improve to not send to a neighbor that already has the info
        ihave = [x for x in self.neighbors
                 if x not in gossip and x != previous]
        return ihave

    def updateLocal(self):
        """
        Update the local variables of the node after sending half of the values
        to a random neighbor

        Returns
        ----------
        (int, int)
            the id of the message
        """
        id = (self.name, self.counter)
        self.counter = self.counter + 1
        self.values = (self.values[0]/2, self.values[1]/2)
        data = self.values
        target = self.neighbors[random.randint(0, len(self.neighbors) - 1)]
        self.data[id] = data
        self.target[id] = target
        self.info[self.name].add(id)
        return id

    def infoToMatrix(self):
        """
        Computes the node info to a matrix,
        used to reduce the message size

        Returns
        ----------
        list(list)
            matrix of the info
        """
        matrixSize = len(list(self.info.keys()))
        res = [[0 for col in range(matrixSize)] for row in range(matrixSize)]
        for node in self.info:
            keyIndex = list(self.info.keys()).index(node)
            res[keyIndex] = self.infoToList(node, matrixSize)
        return res

    def infoToList(self, node, matrixSize):
        """
        Aux function that computes a line of the matrix

        Parameters
        ----------
        node: int
            the info about the node
        matrixSize: size
            the size of the matrix

        Returns
        ----------
        list
            line of the matrix
        """
        res = [0 for elem in range(matrixSize)]
        for (name, id) in self.info[node]:
            nameIndex = list(self.info.keys()).index(name)
            res[nameIndex] = res[nameIndex] + 2**id
        return res

    def matrixToInfo(self, matrix):
        """
        Computes the matrix received from another node to the info

        Returns
        ----------
        list(list)
            the info received
        """
        newInfo = {}
        matrixSize = len(matrix)
        for i in range(matrixSize):
            key = list(self.info.keys())[i]
            newInfo[key] = self.listToInfo(list(matrix[i]))
        return newInfo

    def listToInfo(self, values):
        """
        Aux function that computes a line of the matrix

        Parameters
        ----------
        values: list
            a line of the matrix

        Returns
        ----------
        list
            a line of the info
        """
        res = []
        for i in range(len(values)):
            key = list(self.info.keys())[i]
            value = values[i]
            info = number_to_info(key, value)
            res.extend(info)
        return set(res)

    def start(self):
        """
        Function that generates the initial events

        Returns
        ----------
        list
            a list of initial events
        """
        res = []
        message = {'type': 'iterator'}
        res.append((message, self.name))
        message = {'type': 'knowledge'}
        res.append((message, self.name))
        return res


def number_to_info(key, value):
    """
    Function that generates the info of one node

    Parameters
    ----------
    value: int
        value in the matrix

    Returns
    ----------
    list
        list created by the value
    """
    res = []
    if value == 0:
        return res
    base2 = floor(log2(value))
    while(base2 > -1):
        if(2**base2 <= value):
            res.append((key, base2))
            value = value - 2**base2
        base2 = base2 - 1
    return res
